---
title: "Building Custom Plugins"
description: "Extend your agent with custom capabilities"
---

Plugins are the primary way to extend ClarkOS agents. This guide covers building production-ready plugins.

## Plugin Interface

Every plugin implements this interface:

```typescript
interface Plugin {
  name: string;
  version: string;
  description?: string;
  dependencies?: string[];

  init?(agent: Agent): void | Promise<void>;
  cleanup?(agent: Agent): void | Promise<void>;
  onTick?(context: TickContext): void | Promise<void>;

  actions?: Record<string, ActionHandler>;
}

type ActionHandler = (
  params: Record<string, unknown>,
  agent: Agent
) => Promise<unknown>;
```

## Tick Context

Your plugin receives context on each tick:

```typescript
interface TickContext {
  state: AgentState;
  memories: Memory[];
  knowledge: Knowledge[];
  recentLogs: Log[];
}

interface AgentState {
  mood: "neutral" | "expressive" | "curious" | "excited" | "reflective" | "concerned";
  health: number;      // 0-100
  routine: "morning" | "day" | "evening" | "overnight";
  volatility: number;  // 0-1
  counters: { ticks: number; feeds: number };
  lastTick: string | null;
  cryo: boolean;
}
```

## Basic Plugin

```typescript
import type { Plugin, TickContext } from "@convex-agent/core";

export const loggerPlugin: Plugin = {
  name: "logger",
  version: "1.0.0",
  description: "Logs tick activity",

  onTick(context: TickContext) {
    console.log(`Tick - Mood: ${context.state.mood}, Health: ${context.state.health}`);
    console.log(`Loaded ${context.memories.length} memories`);
  }
};
```

## Plugin Factory Pattern

For configurable plugins, use a factory function:

```typescript
import type { Plugin, TickContext } from "@convex-agent/core";
import type { Agent } from "@convex-agent/core";

interface AnalyticsConfig {
  endpoint: string;
  batchSize: number;
}

export function createAnalyticsPlugin(config: AnalyticsConfig): Plugin {
  const events: unknown[] = [];

  return {
    name: "analytics",
    version: "1.0.0",

    init(agent: Agent) {
      console.log(`Analytics plugin initialized, endpoint: ${config.endpoint}`);
    },

    onTick(context: TickContext) {
      events.push({
        type: "tick",
        mood: context.state.mood,
        health: context.state.health,
        timestamp: Date.now()
      });

      if (events.length >= config.batchSize) {
        this.flush();
      }
    },

    cleanup(agent: Agent) {
      this.flush();
    },

    flush() {
      if (events.length === 0) return;
      // Send to analytics endpoint
      console.log(`Flushing ${events.length} events`);
      events.length = 0;
    },

    actions: {
      async getEventCount() {
        return { success: true, count: events.length };
      },

      async flush() {
        this.flush();
        return { success: true };
      }
    }
  };
}
```

## Lifecycle Hooks

### init()

Called when the agent starts:

```typescript
async init(agent: Agent) {
  // Set up connections
  this.db = await connectToDatabase();
  console.log("Plugin initialized");
}
```

### cleanup()

Called when the agent shuts down:

```typescript
async cleanup(agent: Agent) {
  await this.db.close();
  console.log("Plugin cleaned up");
}
```

### onTick()

Called after every tick:

```typescript
onTick(context: TickContext) {
  // React to state changes
  if (context.state.mood === "expressive" && context.state.health > 50) {
    // Agent is healthy and expressive - good time for output
  }

  // Access memories
  const recentEpisodic = context.memories.filter(m => m.type === "episodic");

  // Check knowledge
  const marketData = context.knowledge.filter(k => k.type === "market");
}
```

## Custom Actions

Plugins expose actions for external invocation:

```typescript
actions: {
  async getData(params: { query: string }, agent: Agent) {
    const results = await this.search(params.query);
    return { success: true, data: results };
  },

  async setConfig(params: { key: string; value: unknown }) {
    this.config[params.key] = params.value;
    return { success: true };
  }
}
```

Invoke actions:

```typescript
// From code
const result = await agent.executeAction("analytics", "getData", {
  query: "recent events"
});

// Via HTTP
// POST /actions/analytics/getData
```

## Plugin Dependencies

Plugins can depend on other plugins:

```typescript
export const enhancedPlugin: Plugin = {
  name: "enhanced",
  version: "1.0.0",
  dependencies: ["analytics", "logger"],

  init(agent: Agent) {
    const analytics = agent.getPlugin("analytics");
    const logger = agent.getPlugin("logger");

    if (!analytics || !logger) {
      throw new Error("Missing required dependencies");
    }
  }
};
```

## Registering Plugins

```typescript
import { Agent } from "@convex-agent/core";
import { ConvexBackend } from "@convex-agent/core/backend";
import { loggerPlugin } from "./plugins/logger";
import { createAnalyticsPlugin } from "./plugins/analytics";

const agent = new Agent({
  backend: new ConvexBackend({ url: process.env.CONVEX_URL! }),
  plugins: [
    loggerPlugin,
    createAnalyticsPlugin({
      endpoint: "https://analytics.example.com",
      batchSize: 100
    })
  ]
});

// Or add later
agent.use(anotherPlugin);
```

## Error Handling

Handle errors gracefully:

```typescript
async onTick(context: TickContext) {
  try {
    await this.riskyOperation();
  } catch (error) {
    console.error("Plugin error:", error);
    // Don't re-throw - let agent continue
  }
}
```

## Testing Plugins

Use dependency injection:

```typescript
export function createTestablePlugin(deps: {
  http: HttpClient;
  logger: Logger;
}): Plugin {
  return {
    name: "testable",
    version: "1.0.0",

    async onTick(context: TickContext) {
      const data = await deps.http.get("/api/data");
      deps.logger.info("Fetched", data);
    }
  };
}

// In tests
const mockHttp = { get: jest.fn().mockResolvedValue({ foo: "bar" }) };
const mockLogger = { info: jest.fn() };
const plugin = createTestablePlugin({ http: mockHttp, logger: mockLogger });
```

## Best Practices

**Keep plugins focused** - One plugin, one responsibility.

**Handle failures gracefully** - Never let plugin errors crash the agent.

**Respect rate limits** - Track API usage, implement cooldowns.

**Make plugins configurable** - Use factory functions with config objects.

**Write tests** - Use dependency injection for testability.

## Next Steps

<CardGroup cols={2}>
  <Card title="Official Plugins" href="/plugins/official">
    Available official plugins
  </Card>
  <Card title="Examples" href="/examples/basic-agent">
    Complete agent implementations
  </Card>
</CardGroup>
