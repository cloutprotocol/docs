---
title: "Plugins SDK"
description: "SDK reference for building plugins"
---

This reference covers the complete plugin interface and development patterns.

## Plugin Interface

```typescript
interface Plugin {
  // Required
  name: string;
  version: string;

  // Optional metadata
  description?: string;
  author?: string;
  license?: string;
  homepage?: string;

  // Dependencies
  dependencies?: string[];

  // Lifecycle hooks
  init?(agent: Agent): void | Promise<void>;
  cleanup?(agent: Agent): void | Promise<void>;

  // Tick hook
  onTick?(context: TickContext): void | Promise<void>;

  // Actions
  actions?: Record<string, ActionHandler>;

  // Event handlers
  on?: Record<string, EventHandler>;

  // Configuration schema (Zod)
  configSchema?: ZodSchema;
}
```

## Creating Plugins

### Basic Plugin

```typescript
import { Plugin } from "./src";

export const myPlugin: Plugin = {
  name: "my-plugin",
  version: "1.0.0",
  description: "Does something useful",

  async init(agent) {
    console.log("Plugin initialized");
  },

  async onTick(context) {
    console.log(`Tick completed, mood: ${context.state.mood}`);
  },

  async cleanup(agent) {
    console.log("Plugin cleaned up");
  },
};
```

### Factory Pattern (Recommended)

```typescript
import { Plugin, PluginConfig } from "./src";
import { z } from "zod";

// Define config schema
const configSchema = z.object({
  enabled: z.boolean().default(true),
  apiKey: z.string(),
  cooldownMs: z.number().default(60000),
});

type Config = z.infer<typeof configSchema>;

export function createMyPlugin(config: Config): Plugin {
  // Validate config
  const validated = configSchema.parse(config);

  // Plugin state
  let lastAction = 0;

  return {
    name: "my-plugin",
    version: "1.0.0",
    configSchema,

    async init(agent) {
      // Initialize with validated config
      console.log("Initialized with:", validated);
    },

    async onTick(context) {
      if (!validated.enabled) return;

      // Respect cooldown
      if (Date.now() - lastAction < validated.cooldownMs) {
        return;
      }

      // Do something
      lastAction = Date.now();
    },
  };
}
```

## Lifecycle Hooks

### init()

Called once when the agent starts. Use for:
- Establishing connections
- Validating configuration
- Registering with external services

```typescript
async init(agent) {
  // Connect to external service
  this.client = await createClient({
    apiKey: this.config.apiKey,
  });

  // Verify connection
  const status = await this.client.ping();
  if (!status.ok) {
    throw new Error("Failed to connect");
  }

  // Store reference for other hooks
  agent.setContext("myClient", this.client);

  console.log("Plugin ready");
}
```

### cleanup()

Called when the agent stops. Use for:
- Closing connections
- Flushing buffers
- Saving state

```typescript
async cleanup(agent) {
  // Flush pending operations
  await this.flushQueue();

  // Close connections
  await this.client.close();

  console.log("Plugin cleaned up");
}
```

### onTick()

Called after every tick. Use for:
- Reacting to state changes
- Executing actions based on conditions
- Generating content

```typescript
async onTick(context) {
  // Access current state
  const { mood, health } = context.state;

  // Access tick response
  const { summary, artifacts } = context.response;

  // Access memories and knowledge
  const { memories, knowledge } = context;

  // Check conditions
  if (mood === "expressive" && health > 50) {
    // Do something
  }

  // Process artifacts
  for (const artifact of artifacts) {
    if (artifact.type === "tweet") {
      await this.postTweet(artifact.content);
    }
  }
}
```

## TickContext

The context passed to `onTick`:

```typescript
interface TickContext {
  // Current state (after tick update)
  state: AgentState;

  // LLM response from this tick
  response: {
    mood: string;
    health: number;
    volatility: number;
    summary: string;
    detail: string;
    remark?: string;
  };

  // Data retrieved for this tick
  memories: Memory[];
  knowledge: KnowledgeItem[];

  // Time of day
  routine: "morning" | "day" | "evening" | "overnight";

  // Artifacts generated by LLM
  artifacts: Artifact[];

  // Helper methods
  remember(memory: NewMemory): Promise<string>;
  recall(query: string, options?: RecallOptions): Promise<Memory[]>;
  getRecentThought(): ConsciousThought | null;
  shouldAct(): boolean;
  getActionPriority(): number;

  // Inter-plugin communication
  emit(event: string, data: any): void;
  getPlugin(name: string): Plugin;

  // Access agent context
  getContext(key: string): any;
  setContext(key: string, value: any): void;
}
```

## Plugin Actions

Expose callable actions:

```typescript
export const tradingPlugin: Plugin = {
  name: "trading",
  version: "1.0.0",

  actions: {
    // Actions are async functions
    async buy(symbol: string, amount: number, options?: BuyOptions) {
      const order = await this.exchange.buy(symbol, amount, options);
      return {
        orderId: order.id,
        filled: order.status === "filled",
        price: order.filledPrice,
      };
    },

    async sell(symbol: string, amount: number) {
      const order = await this.exchange.sell(symbol, amount);
      return { orderId: order.id };
    },

    async getPortfolio() {
      return await this.exchange.getPositions();
    },
  },
};

// Calling actions
const result = await agent.action("trading.buy", "ETH", 100);
const portfolio = await agent.action("trading.getPortfolio");
```

## Event System

### Emitting Events

```typescript
async onTick(context) {
  await this.postTweet(content);

  // Emit event for other plugins
  context.emit("tweet_posted", {
    content,
    tweetId: result.id,
    timestamp: Date.now(),
  });
}
```

### Handling Events

```typescript
export const analyticsPlugin: Plugin = {
  name: "analytics",
  version: "1.0.0",

  on: {
    // Handle events from other plugins
    tweet_posted: async (data, context) => {
      await trackEvent("social", "tweet", data);
    },

    memory_created: async (data, context) => {
      await trackEvent("memory", "create", {
        type: data.type,
        importance: data.importance,
      });
    },

    // System events
    tick_complete: async (data, context) => {
      await trackEvent("agent", "tick", {
        duration: data.duration,
        mood: data.mood,
      });
    },
  },
};
```

## Plugin Dependencies

Declare and use dependencies:

```typescript
export const enhancedTwitter: Plugin = {
  name: "enhanced-twitter",
  version: "1.0.0",
  dependencies: ["twitter", "analytics"],

  async init(agent) {
    // Get dependent plugins
    const twitter = agent.getPlugin("twitter");
    const analytics = agent.getPlugin("analytics");

    // Wrap functionality
    const originalPost = twitter.actions.post;
    twitter.actions.post = async (content) => {
      const result = await originalPost(content);
      await analytics.track("tweet", result);
      return result;
    };
  },
};
```

## Configuration

### Runtime Configuration

```typescript
// Update config at runtime
agent.configurePlugin("my-plugin", {
  enabled: false,
  newSetting: "value",
});

// In the plugin
export const myPlugin: Plugin = {
  name: "my-plugin",

  // Called when config changes
  onConfigChange(newConfig, agent) {
    this.config = { ...this.config, ...newConfig };
  },
};
```

### Environment-Based

```typescript
export const myPlugin = createMyPlugin({
  enabled: process.env.PLUGIN_ENABLED === "true",
  apiKey: process.env.PLUGIN_API_KEY!,
  environment: process.env.NODE_ENV || "development",
});
```

## Error Handling

```typescript
async onTick(context) {
  try {
    await this.riskyOperation();
  } catch (error) {
    // Log the error
    console.error("Plugin error:", error);

    // Optionally affect agent health
    await context.setState({
      health: context.state.health - 2,
    });

    // Store for learning
    await context.remember({
      type: "procedural",
      content: `Error in ${this.name}: ${error.message}`,
      importance: 0.7,
      metadata: { error: true },
    });

    // Don't re-throw - let agent continue
  }
}
```

## Testing Plugins

```typescript
import { createTestAgent, createMockContext } from "./src/testing";

describe("My Plugin", () => {
  test("onTick handles expressive mood", async () => {
    const mockPost = jest.fn();
    const plugin = createMyPlugin({
      apiKey: "test",
      post: mockPost,
    });

    const context = createMockContext({
      state: { mood: "expressive", health: 80 },
      response: { summary: "Test summary" },
    });

    await plugin.onTick(context);

    expect(mockPost).toHaveBeenCalled();
  });
});
```

## Publishing Plugins

### Package Structure

```
my-clarkos-plugin/
├── src/
│   ├── index.ts
│   ├── plugin.ts
│   └── types.ts
├── tests/
│   └── plugin.test.ts
├── package.json
├── tsconfig.json
└── README.md
```

### Package.json

```json
{
  "name": "clarkos-plugin-myname",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "keywords": ["clarkos-agent-plugin", "convex-agent-plugin"],
  "peerDependencies": {
    "./src": "^1.0.0"
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent SDK" icon="robot" href="/api-reference/sdk/agent">
    Main agent class reference.
  </Card>
  <Card title="Plugin Guide" icon="hammer" href="/guides/custom-plugins">
    Step-by-step plugin development.
  </Card>
</CardGroup>
