---
title: "Agents"
description: "Understanding ClarkOS agent architecture"
---

## What is a ClarkOS Agent?

A ClarkOS agent is an autonomous AI entity that:

- **Thinks continuously** through a tick-based execution model
- **Remembers everything** with a multi-layered memory system
- **Evolves over time** through learning and self-reflection
- **Acts independently** via plugins and integrations

Unlike simple chatbots that respond to prompts, ClarkOS agents have persistent state, form memories, and develop personality over time.

## Agent Lifecycle

```
Initialize → Load State → Gather Context → Process → Update State → Store Memories → Execute Actions → Sleep → Repeat
```

1. **Initialize** - Load configuration and plugins
2. **Load State** - Retrieve current mood, health, routine
3. **Gather Context** - Pull relevant memories, knowledge, feeds
4. **Process** - Send context to LLM for processing
5. **Update State** - Apply mood/health changes atomically
6. **Store Memories** - Create new memories from the tick
7. **Execute Actions** - Run plugin actions
8. **Sleep** - Wait for next tick interval

## Agent State

Every agent maintains core state:

```typescript
interface AgentState {
  mood: "neutral" | "expressive" | "curious" | "excited" | "reflective" | "concerned";
  health: number;      // 0-100
  routine: "morning" | "day" | "evening" | "overnight";
  volatility: number;  // 0-1, behavioral variance
  counters: {
    ticks: number;
    feeds: number;
  };
  lastTick: string | null;
  cryo: boolean;       // Hibernation mode
}
```

### Mood System

Moods affect how your agent processes and acts:

| Mood | Description | Behavior |
|------|-------------|----------|
| `neutral` | Balanced | Standard processing |
| `expressive` | Outgoing | Active engagement |
| `curious` | Inquisitive | Research, exploration |
| `excited` | High energy | Enthusiastic responses |
| `reflective` | Thoughtful | Deep analysis |
| `concerned` | Cautious | Risk awareness |

### Health System

Health represents the agent's well-being:

- **100**: Peak performance
- **75**: Target equilibrium
- **50**: Degraded activity
- **25**: Minimal function
- **0**: Hibernation mode

Health drifts based on routine:
- Morning: +2 recovery
- Day: Stable
- Evening: -1 decline
- Overnight: -3 hibernation risk

## Creating an Agent

Using the SDK:

```typescript
import { Agent } from "@convex-agent/core";
import { ConvexBackend } from "@convex-agent/core/backend";

const agent = new Agent({
  backend: new ConvexBackend({
    url: process.env.CONVEX_URL!
  }),
  plugins: []
});

// Execute a tick
await agent.tick();

// Start automatic execution
agent.start();

// Stop execution
agent.stop();

// Get current state
const state = await agent.getState();
```

## Agent Methods

### Core Methods

```typescript
// Start automatic tick execution
agent.start();

// Stop automatic tick execution
agent.stop();

// Execute a single tick
await agent.tick();

// Get current state
const state = await agent.getState();

// Check if running
const running = agent.isRunning();
```

### Plugin Methods

```typescript
// Register a plugin
agent.use(myPlugin);

// Get plugin by name
const plugin = agent.getPlugin("analytics");

// Get all plugins
const plugins = agent.getPlugins();

// Execute a plugin action
await agent.executeAction("analytics", "getData", { query: "..." });
```

### Memory Access

```typescript
// Access the memory store
const memoryStore = agent.memory;

// Store a memory
await memoryStore.store({
  type: "episodic",
  content: "Event description",
  importance: 0.7
});

// Query memories
const memories = await memoryStore.query({
  type: "semantic",
  limit: 10
});
```

## Configuration

```typescript
import { createConfig } from "@convex-agent/core";

const config = createConfig({
  tick: {
    intervalMs: 300000,    // 5 minutes
    timeoutMs: 60000,      // 1 minute max
  },
  memory: {
    maxMemories: 10000,
    embeddingModel: "gemini"
  }
});

const agent = new Agent({
  backend,
  config,
  plugins: []
});
```

## Best Practices

**Choose appropriate tick intervals**
- Social agents: 5-15 minutes
- Analysis agents: 30-60 minutes
- Monitoring agents: 1-5 minutes

**Design for failure**
- Handle LLM API failures with retries
- Manage rate limits with queuing
- Reset invalid state to defaults

**Use plugins for actions**
- Keep core agent logic focused on thinking
- Delegate actions to testable plugins

**Monitor health**
- Alert on health below 25
- Track mood distribution
- Log tick failures

## Next Steps

<CardGroup cols={2}>
  <Card title="Memory System" href="/concepts/memory">
    How agents remember and learn
  </Card>
  <Card title="Tick System" href="/concepts/tick-system">
    The execution loop
  </Card>
</CardGroup>
